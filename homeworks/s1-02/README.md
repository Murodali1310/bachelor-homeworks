# Постановка задачи

Это задание предназначено для того, чтобы закрепить усвоение материала лекции, научиться использовать pattern matching, строить ADT и понимать функции как множества. Необходимо:


## Стоимость паркета в доме

В этой задаче вам необходимо смоделировать дом через один кейс класс для любого типа дома.

Дом может быть премиальным или эконом-класса, может быть несколько этажей, длина см, ширина см, высота см.
Создание кейс класса должно происходить через смарт-конструктор, который должен проверять:
* Этажи, ширина, длина, высота > 0
  Если переданы невенрные данные, то бросать исключение.

Также, необходимо реализовать функцию в кейс классе для рассчета стоимости паркета:
* Для премиального дома и кол-во этажей < 5:
    * 3^(кол-во этажей) * (Длина + Ширина + Высота)
* Для премиального дома и кол-во этажей >= 5:
    * 2^(кол-во этажей) * (Длина + Ширина + Высота),
* Для дома эконом-класса:
    * Длина * ширина * Высота + кол-во этажей * 10000

Функция подсчета паркета должна уметь определять тип дома через паттерн матчинг.

## Настройка запроса пароля пользователя

1. Реализовать смарт-конструктор в объекте-компаньоне UserPhone. 
Он должен пропускать только российские номера телефонов. 
Считаем номер российским, если он начинается с +79 и имеет 11 цифр.
2. Реализовать метод UserSettingsService#getPasswordSettings
   1. Если пользователь не найден, то вернуть None
   2. Если тип пользователя - Dummy, то запрос пароля запрещен и пароль не установлен
   2. Если тип пользователя - Customer, то запрос пароля разрешен, а признак установлен ли пароль строится из двух 
   составляющих - пароль постоянный или отправлен пользователю
   3. Если тип пользователя AlmostCustomer и у пользователя нет телефона, то вернуть None
   3. Если тип пользователя AlmostCustomer и телефон есть, то нужно сходить поискать продукты пользователя. 
      1. Если есть тяжелые продукты, то запрос пароля разрешен, а установлен ли пароль считается аналогично п.2
      2. Если есть легкие продукты и пароль установлен (п.2), то пароль доступен, иначе пароль не доступен
      3. Если продукты не найдены, то запрос пароля разрешен, а установлен ли пароль считается аналогично п.2

# Изоморфизм типов
* Реализуйте функции, которые создают экземпляры объектов класса Equivalent
* Для создания можете пользоваться методом **apply** объекта-компаньона
* Пример:
```scala
def boolToThree: Equivalent[Boolean => Ternary, (Ternary, Ternary)] =
  Equivalent {
    forward: Boolean => Ternary => ???
  } {
  backward: (Ternary, Ternary) => ???
  }
```