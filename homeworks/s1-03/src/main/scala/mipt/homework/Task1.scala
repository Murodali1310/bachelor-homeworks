package mipt.homework

object Task1 extends App {

  /**
    * Реализуйте метод take, который возвращает n первых элементов исходного списка.
    * Для реализации используйте хвостовую рекурсию, методы foldLeft и reverse из класса списка.
    * Метод должен работать за линейное время
    */
  def take[A](l: MyList[A], n: Int): MyList[A] = ???

  /**
    * Реализуйте метод takeRight, который возвращает n последних элементов исходного списка.
    * Для реализации используйте хвостовую рекурсию, методы foldLeft и reverse из класса списка.
    * Метод должен работать за линейное время
    */
  def takeRight[A](l: MyList[A], n: Int): MyList[A] = ???

  /**
    * Реализуйте метод takeWhile, который идет по переданному списку с головы и собирает элементы в новый список до тех пор, пока предикат выполняется.
    * Для реализации используйте хвостовую рекурсию, методы foldLeft и reverse из класса списка.
    * Метод должен работать за линейное время.
    */
  def takeWhile[A](l: MyList[A], predicate: A => Boolean): MyList[A] = ???

  /**
    * Реализуйте метод dropWhile, который отбрасывает элементы исходного списка начиная с головы, пока они удовлетворяют переданному предикату.
    * Использовать для реализации хвостовую рекурсию, методы foldLeft и reverse из класса списка.
    * Метод должен работать за линейное время
    */
  def dropWhile[A](l: MyList[A], predicate: A => Boolean): MyList[A] = ???

  /**
    * Реализуйте метод zip, который из двух списков делает один, объединяя их элементы попарно в анонимный кортеж (tuple).
    * Итоговый список должен иметь длину, равную длине более короткого списка, элементы из хвоста длинного списка игнорируются.
    * Для реализации использовать хвостовую рекурсию, методы foldLeft и reverse из класса списка.
    * Метод должен работать за линейное время
    */
  def zip[A, B](l1: MyList[A], l2: MyList[B]): MyList[(A, B)] = ???

}
